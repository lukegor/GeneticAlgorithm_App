using GeneticAlgorithm_App.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GeneticAlgorithm_App
{
    /// <summary>
    /// Class responsible for handling a single generation cycle of the genetic algorithm.
    /// </summary>
    internal class GenerationCycle
    {
        /// <summary>
        /// Calculates the number of bits required to represent a range of values based on the given parameters.
        /// </summary>
        /// <param name="a">The lower bound of the range.</param>
        /// <param name="b">The upper bound of the range.</param>
        /// <param name="d">The precision or the smallest increment between values.</param>
        /// <returns>The number of bits (L value) needed to represent the range.</returns>
        public static int GetLValue(int a, int b, float d) =>
            (int)Math.Ceiling(Math.Log2(((b - a) / d) + 1));

        /// <summary>
        /// Fills an array with values generated by the provided function.
        /// </summary>
        /// <param name="n">Number of elements in the array.</param>
        /// <param name="valueGenerator">Function to generate the values.</param>
        /// <returns>Array filled with generated values.</returns>
        public double[] FillArray(int n, Func<int, double> valueGenerator)
        {
            double[] result = new double[n];
            for (int i = 0; i < n; i++)
            {
                result[i] = valueGenerator(i);
            }
            return result;
        }

        /// <summary>
        /// Generates an array of random numbers within specified range with the specified precision.
        /// </summary>
        /// <param name="a">Lower bound.</param>
        /// <param name="b">Upper bound.</param>
        /// <param name="n">Number of elements in the array.</param>
        /// <param name="prec">Precision of the generated numbers.</param>
        /// <returns>Array of random numbers .</returns>
        public double[] FillFirstTwoColumnsAndXrealArray(int a, int b, int n, int prec) =>
            FillArray(n, _ => RandomNumberHelper.GetRandomNumberWithPrecision(a, b, prec));

        /// <summary>
        /// Rounds the values in the last generation of real numbers to the specified precision.
        /// </summary>
        /// <param name="prec">The precision to which the real numbers should be rounded.</param>
        /// <param name="lastXreals">The array of real numbers from the last generation.</param>
        /// <returns>An array of real numbers rounded to the specified precision.</returns>
        public double[] RoundXrealArray(int prec, double[] lastXreals) =>
            lastXreals.Select(x => Math.Round(x, prec)).ToArray();

        /// <summary>
        /// Fills an array with the function values for each real number in the specified array.
        /// </summary>
        /// <param name="xrealArray">The array of real numbers.</param>
        /// <returns>An array of function values corresponding to the real numbers.</returns>
        public double[] FillFxColumnAndFxValuesArray(double[] xrealArray) =>
            FillArray(xrealArray.Length, i => CountFxValue(xrealArray[i]));

        /// <summary>
        /// Computes the function value for a given real number.
        /// </summary>
        /// <param name="x">The real number for which to compute the function value.</param>
        /// <returns>The computed function value.</returns>
        public static double CountFxValue(double x) =>
            x % 1 * (Math.Cos(20 * Math.PI * x) - Math.Sin(x));

        /// <summary>
        /// Fills an array with the G(x) values for each function value in the specified array.
        /// </summary>
        /// <param name="d">A constant used in the G(x) calculation. Also precision indicator.</param>
        /// <param name="fxValuesArray">The array of function values.</param>
        /// <returns>An array of G(x) values corresponding to the function values.</returns>
        public double[] FillGxColumnAndGxValuesArray(float d, double[] fxValuesArray)
        {
            double min = fxValuesArray.Min();
            double max = fxValuesArray.Max();
            return FillArray(fxValuesArray.Length, i => (double)CountGxValue(fxValuesArray[i], min, max, d));
        }

        /// <summary>
        /// Computes the G(x) value for a given function value.
        /// </summary>
        /// <param name="fxValue">The function value for which to compute the G(x) value.</param>
        /// <param name="fmin">The minimum function value in the current generation.</param>
        /// <param name="fmax">The maximum function value in the current generation.</param>
        /// <param name="d">A constant used in the G(x) calculation. Also precision indicator.</param>
        /// <returns>The computed G(x) value.</returns>
        public decimal CountGxValue(double fxValue, double fmin, double fmax, float d) =>
            (decimal)fxValue - (decimal)fmin + (decimal)d;

        /// <summary>
        /// Fills an array with the P(i) values for each G(x) value in the specified array.
        /// </summary>
        /// <param name="gxValuesArray">The array of G(x) values.</param>
        /// <returns>An array of P(i) values corresponding to the G(x) values.</returns>
        public double[] FillP_iColumnAndPArray(double[] gxValuesArray)
        {
            double gxSum = gxValuesArray.Sum();
            return FillArray(gxValuesArray.Length, i => gxValuesArray[i] / gxSum);
        }

        /// <summary>
        /// Fills an array with the Q(i) values for each P(i) value in the specified array.
        /// </summary>
        /// <param name="pArray">The array of P(i) values.</param>
        /// <returns>An array of Q(i) values corresponding to the P(i) values.</returns>
        public double[] FillQ_iColumnAndQArray(double[] pArray) =>
            FillArray(pArray.Length, i => pArray.Take(i + 1).Sum());

        /// <summary>
        /// Fills an array with random values between 0 and 1.
        /// </summary>
        /// <param name="n">The number of random values to generate.</param>
        /// <returns>An array of random values between 0 and 1.</returns>
        public double[] FillRColumnAndRArray(int n) =>
            FillArray(n, _ => RandomNumberHelper.GetNextDouble());

        /// <summary>
        /// Fills an array with selected values based on specified criteria involving the Q and R arrays.
        /// </summary>
        /// <param name="prec">The precision to which the selected values should be rounded.</param>
        /// <param name="xrealArray">The array of real numbers to select from.</param>
        /// <param name="qArray">The array of Q values used for comparison.</param>
        /// <param name="rArray">The array of R values used for comparison.</param>
        /// <returns>An array of selected values, rounded to the specified precision.</returns>
        public double[] FillSelectedColumnAndSelectedArray(int prec, ReadOnlySpan<double> xrealArray, ReadOnlySpan<double> qArray, ReadOnlySpan<double> rArray)
        {
            int n = xrealArray.Length;
            double[] selected = new double[n];

            for (int rIterator = 0; rIterator < n; ++rIterator)
            {
                for (int qIterator = 0; qIterator < n; ++qIterator)
                {
                    double qValue = qArray[qIterator];
                    double rValue = rArray[rIterator];

                    if (qIterator == 0)
                    {
                        if (qValue >= rValue)
                        {
                            selected[rIterator] = Math.Round(xrealArray[qIterator], prec);
                            //dataGridView1[7, rIterator].Value = selected[rIterator];
                        }
                    }

                    else
                    {
                        double lastQValue = qArray[qIterator - 1];

                        if (qValue >= rValue && lastQValue < rValue)
                        {
                            selected[rIterator] = Math.Round(xrealArray[qIterator], prec);
                            //dataGridView1[7, rIterator].Value = selected[rIterator];
                        }
                    }
                }
            }
            return selected;
        }

        /// <summary>
        /// Converts the selected real numbers to binary representation strings.
        /// </summary>
        /// <param name="a">The first parameter used for conversion.</param>
        /// <param name="b">The second parameter used for conversion.</param>
        /// <param name="l">The length of the binary representation.</param>
        /// <param name="selected">The array of selected real numbers to convert.</param>
        /// <returns>An array of binary representation strings corresponding to the selected real numbers.</returns>
        public string[] FillXbinColumnAndXbinArray(int a, int b, int l, ReadOnlySpan<double> selected) =>
            selected.ToArray().Select(value => ConversionHelper.XIntToXBin(ConversionHelper.XRealToXInt(a, b, value, l), l)).ToArray();

        /// <summary>
        /// Fills an array with parent strings based on a probability and returns them along with their data grid view representations.
        /// </summary>
        /// <param name="n">The number of parents to generate.</param>
        /// <param name="p_k">The probability threshold for selecting a parent.</param>
        /// <param name="xbinArray">The array of binary representation strings from which to select parents.</param>
        /// <returns>A tuple containing an array of selected parent strings and their corresponding data grid view representations.</returns>
        public (string[], object[]) FillParentsColumnAndParentsArray(int n, double p_k, ReadOnlySpan<string> xbinArray)
        {
            string[] parents = new string[n];
            object[] parentsFromDataGridView = new object[n];

            do
            {
                for (int i = 0; i < n; ++i)
                {
                    if (string.IsNullOrEmpty(parents[i]))
                    {
                        double tmpR = RandomNumberHelper.GetNextDouble();
                        if (tmpR <= p_k)
                        {
                            parents[i] = xbinArray[i];
                            parentsFromDataGridView[i] = parents[i];
                        }
                    }
                }
            } while (parents.Count(parent => parent != string.Empty) == 1);

            return (parents, parentsFromDataGridView);
        }

        /// <summary>
        /// Counts the number of non-empty parent strings in the array.
        /// </summary>
        /// <param name="parents">The array of parent strings.</param>
        /// <returns>The count of non-empty parent strings.</returns>
        public int CountParents(string[] parents) =>
            parents.Count(p => !string.IsNullOrEmpty(p));

        /// <summary>
        /// Filters out non-empty parent strings and their original indexes from the array.
        /// </summary>
        /// <param name="parentCounter">The number of parents to include in the filtered result.</param>
        /// <param name="parents">The array of parent strings to filter.</param>
        /// <returns>A tuple containing an array of filtered parent strings and an array of their original indexes.</returns>
        public (string[], int[]) FilterParentsAndTheirIndexes(int parentCounter, ReadOnlySpan<string> parents)
        {
            string[] filteredParents = new string[parentCounter];
            int[] indexesOfFiltered = new int[parentCounter];
            for (int i = 0, j = 0; j < filteredParents.Length; ++i)
            {
                if (!string.IsNullOrEmpty(parents[i]))
                {
                    filteredParents[j] = parents[i];
                    indexesOfFiltered[j] = i;
                    ++j;
                }
            }

            return (filteredParents, indexesOfFiltered);
        }

        /// <summary>
        /// Performs pairing of filtered parents, generates a random number for each pair, and adds the pairs to a list.
        /// </summary>
        /// <param name="l">The upper bound for the random number generation (exclusive).</param>
        /// <param name="filteredParents">A span of filtered parent strings to be paired.</param>
        /// <returns>A list of tuples where each tuple contains a pair of parent strings and a random number.</returns>
        public List<Tuple<string, string, int>> PerformPairingAndAddToListWithRandomNumber(int l, ReadOnlySpan<string> filteredParents)
        {
            List<Tuple<string, string, int>> pairs = new List<Tuple<string, string, int>>();
            for (int i = 0; i < filteredParents.Length - 1; i += 2)
            {
                int randomNum = RandomNumberHelper.GetRandomIntNumber(0, l - 2);
                Tuple<string, string, int> pair = new Tuple<string, string, int>(filteredParents[i], filteredParents[i + 1], randomNum);
                pairs.Add(pair);
            }
            if (filteredParents.Length % 2 == 1)
            {
                pairs.Add(new Tuple<string, string, int>(filteredParents[filteredParents.Length - 1], filteredParents[0], RandomNumberHelper.GetRandomIntNumber(0, l - 2)));
            }

            return pairs;
        }

        /// <summary>
        /// Fills the P_c column with values based on the pairs and the provided parents data.
        /// </summary>
        /// <param name="parents">A span of parent strings.</param>
        /// <param name="pairs">A list of tuples representing pairs of parent strings and associated random numbers.</param>
        /// <param name="parentsFromDataGridView">An array of objects representing parent strings from a data grid view.</param>
        public void FillP_cColumn(ReadOnlySpan<string> parents, List<Tuple<string, string, int>> pairs, object[] parentsFromDataGridView)
        {
            int pom = 0;
            int pom2 = 0;
            int[] Pcs = new int[parents.Length];

            //for(int j = 0; j < parents.Length; ++j)
            //{
            //	bool check = dataGridView1[9, j].Value == parents[j];
            //	System.Diagnostics.Debug.WriteLine(dataGridView1[9, j].Value + " " + parents[j] + " " + check);
            //}
            //System.Diagnostics.Debug.WriteLine("new");
            for (int z = pom; z < parents.Length; ++z)
            {
                if (!string.IsNullOrEmpty(parents[z]))
                {
                    for (int pairIterator = pom2; pairIterator < pairs.Count; ++pairIterator)
                    {
                        //bool check = parents[z] == dataGridView1[9, z].Value;
                        //System.Diagnostics.Debug.WriteLine(check + "\n");
                        if (parentsFromDataGridView[z].ToString() == pairs[pairIterator].Item1 || parentsFromDataGridView[z].ToString() == pairs[pairIterator].Item2)
                        {
                            //bool check1 = parents[z] == pairs[pairIterator].Item1;
                            //bool check2 = parents[z] == pairs[pairIterator].Item2;
                            //System.Diagnostics.Debug.WriteLine("1. gridview: " + dataGridView1[9, z].Value + "\nrodzic: " + parents[z] + check1 + check2);
                            Pcs[z] = pairs[pairIterator].Item3;
                            //dataGridView1[10, z].Value = Pcs[z];
                            break;
                        }
                        //if (dataGridView1[9, z].Value == pairs[pairIterator].Item1 || dataGridView1[9, z].Value == pairs[pairIterator].Item2)
                        //{
                        //bool check1 = dataGridView1[9, z].Value == pairs[pairIterator].Item1;
                        //bool check2 = dataGridView1[9, z].Value == pairs[pairIterator].Item2;
                        //System.Diagnostics.Debug.WriteLine("\n2. gridview: " + dataGridView1[9, z].Value + "\nrodzic: " + parents[z] + check1 + check2 + "\n");
                        //}
                        //if (dataGridView1[9, z].Value == pairs[pairIterator].Item1 || dataGridView1[9, z].Value == pairs[pairIterator].Item2)
                        //{

                        //string parent = parents[z];
                        //string item1 = pairs[pairIterator].Item1;
                        //string item2 = pairs[pairIterator].Item2;

                        //bool check1 = dataGridView1[9, z].Value == item1;
                        //	bool check2 = dataGridView1[9, z].Value == item2;
                        //	bool check3 = parent == item1;
                        //	bool check4 = parent == item2;
                        //bool check5 = dataGridView1[9, z].Value == parents[z];
                        //	System.Diagnostics.Debug.WriteLine(check1 + " " + check2 + " vs " + check3 + " " + check4 + " " + check5);

                        //}
                        //if (parents[z] == pairs[pairIterator].Item1 || parents[z] == pairs[pairIterator].Item2)
                        //{
                        //	break;
                        //}

                        ++pom2;
                    }
                }
                ++pom;
            }
        }

        /// <summary>
        /// Performs crossover between pairs of parent strings to generate child strings.
        /// </summary>
        /// <param name="pairs">A list of tuples representing pairs of parent strings and associated random numbers.</param>
        /// <returns>A list of generated child strings from the crossover operation.</returns>
        public List<string> PerformCrossingAndReturnOnlyChildren(List<Tuple<string, string, int>> pairs)
        {
            var children = new List<string>();

            foreach (var (parent1, parent2, cutPoint) in pairs)
            {
                int length1 = parent1.Length;
                int length2 = parent2.Length;

                string child1 = parent1.Substring(0, cutPoint) + parent2.Substring(cutPoint);
                string child2 = parent2.Substring(0, cutPoint) + parent1.Substring(cutPoint);

                children.Add(child1);
                children.Add(child2);
            }

            return children;
        }

        /// <summary>
        /// Saves generated child strings to a post-crossing array at specified indexes.
        /// </summary>
        /// <param name="n">The total number of elements in the post-crossing array.</param>
        /// <param name="children">A list of generated child strings.</param>
        /// <param name="indexesOfFiltered">A span of indexes where the child strings should be placed in the post-crossing array.</param>
        /// <returns>An array of post-crossing strings where the children have been placed at the specified indexes.</returns>
        public string[] SaveChildrenToPostCrossingArray(int n, List<string> children, ReadOnlySpan<int> indexesOfFiltered)
        {
            string[] earlyCrossing = new string[n];

            int i = 0;
            foreach (int index in indexesOfFiltered)
            {
                earlyCrossing[index] = children[i];
                ++i;
            }

            return earlyCrossing;
        }

        public void FillEmptyFieldsWithRelevantXbin(ReadOnlySpan<string> xbinArr, string[] allPostCrossing)
        {
            int i = 0;
            foreach (string xBin in xbinArr)
            {
                if (string.IsNullOrEmpty(allPostCrossing[i]))
                {
                    allPostCrossing[i] = xBin;
                }
                ++i;
            }
        }

        public string[] HandlePostCrossingArray(int n, List<string> children, ReadOnlySpan<int> indexesOfFiltered, ReadOnlySpan<string> xbinArr)
        {
            string[] allPostCrossing = new string[n];

            //save every child to the array
            allPostCrossing = SaveChildrenToPostCrossingArray(n, children, indexesOfFiltered);

            //save every xbin in case a field in array "post crossing" is empty
            //fill every empty field in the "crossing" column with xbin (according to table)
            //MODIFIES array without returning
            FillEmptyFieldsWithRelevantXbin(xbinArr, allPostCrossing);

            return allPostCrossing;
        }

        public int[,] MarkMutatedIndexes(int n, int l)
        {
            int[,] mutatedIndexes = new int[n, l];
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < l; j++)
                {
                    mutatedIndexes[i, j] = -1;
                }
            }

            return mutatedIndexes;
        }

        public (double[], double[]) HandleTwoLastColumns(int a, int b, int n, int l, string[] postCrossingCopy, float d)
        {
            double[] finalXRealArray = new double[n];
            double[] finalFxValuesArray = new double[n];

            for (int i = 0; i < n; ++i)
            {
                finalXRealArray[i] = Math.Round(ConversionHelper.XIntToXReal(a, b, ConversionHelper.XBinToXInt(postCrossingCopy[i]), l, d), GeneticAlgorithmParams.GetPrecInNumber(d));
                //dataGridView1[14, i].Value = finalXRealArray[i];

                finalFxValuesArray[i] = CountFxValue(finalXRealArray[i]);
                //dataGridView1[15, i].Value = finalFxValuesArray[i];
            }

            return (finalXRealArray, finalFxValuesArray);
        }

        public double[] HandleFinalXreals(int a, int b, int n, int l, string[] postCrossingCopy, float d) =>
            postCrossingCopy.Select(xbin => Math.Round(ConversionHelper.XIntToXReal(a, b, ConversionHelper.XBinToXInt(xbin), l, d), GeneticAlgorithmParams.GetPrecInNumber(d))).ToArray();

        public double[] HandleFinalFxValues(int n, ReadOnlySpan<double> finalXreals)
        {
            double[] finalFxValuesArray = new double[n];

            for (int i = 0; i < n; ++i)
            {
                finalFxValuesArray[i] = CountFxValue(finalXreals[i]);
            }

            return finalFxValuesArray;
        }

        public void Fill2DArrayWithMutatedBitsIndexes(int n, int l, float p_m, ReadOnlySpan<string> allPostCrossing, int[,] mutatedIndexes)
        {
            //StringBuilder[] sb = new StringBuilder[n];

            //for (int i = 0; i < n; i++)
            //{
            //    sb[i] = new StringBuilder();
            //}


            for (int i = 0; i < n; ++i)
            {
                if (allPostCrossing[i] != null) continue;

                string postCrossingString = allPostCrossing[i];

                for (int j = 0; j < postCrossingString.Length; ++j)
                {
                    double randomVal = RandomNumberHelper.GetRandomFloatNumber(0, 1);

                    if (randomVal <= p_m)
                    {
                        //if (sb[i].Length != 0)
                        //{
                        //    sb[i].Append(", ");
                        //}
                        //sb[i].Append($"{j}");

                        mutatedIndexes[i, j] = j;
                    }
                    ++j;
                }
                //dataGridView1[12, i].Value = sb[i];
            }
        }

        public int[,] HandleMutatedBitsArray(int n, int l, float p_m, ReadOnlySpan<string> allPostCrossing)
        {
            int[,] mutatedIndexes = new int[n, l];

            //if an index is not mutated, fill it with -1, to differentiate from index 0 (since c# basically assigns 0 to empty field in int array)
            mutatedIndexes = MarkMutatedIndexes(n, l);

            //loop every row, then loop every char (0/1) in each string
            //in order to check condition and find mutated bits
            //WARNING: this function operates on true mutatedIndexes array, without returning
            Fill2DArrayWithMutatedBitsIndexes(n, l, p_m, allPostCrossing, mutatedIndexes);

            return mutatedIndexes;
        }

        public string[] AfterMutationColumnAndFillPostMutationArray(int n, int l, int[,] mutatedIndexes, string[] allPostCrossing)
        {
            //make a copy of post-crossing generation just in case
            string[] postMutation = (string[])allPostCrossing.Clone();

            for (int i = 0; i < n; ++i)
            {
                for (int j = 0; j < l; ++j)
                {
                    int value = mutatedIndexes[i, j];
                    if (value != -1)
                    {
                        if (postMutation[i][j] == '0')
                        {
                            postMutation[i] = postMutation[i].Remove(j, 1).Insert(j, "1");
                        }
                        else if (postMutation[i][j] == '1')
                        {
                            postMutation[i] = postMutation[i].Remove(j, 1).Insert(j, "0");
                        }
                    }
                }
            }

            return postMutation;
        }

        public void UpdateEliteArrays(int n, bool isElite, double[] xrealArray, double[] fxValuesArray, int eliteIndex, double[] finalXRealArray, double[] finalFxValuesArray)
        {
            if (isElite && eliteIndex >= 0)
            {
                if (finalXRealArray[eliteIndex] != xrealArray[eliteIndex])
                {
                    if (finalFxValuesArray[eliteIndex] < fxValuesArray[eliteIndex])
                    {
                        finalXRealArray[eliteIndex] = xrealArray[eliteIndex];
                        finalFxValuesArray[eliteIndex] = fxValuesArray[eliteIndex];
                    }
                    else
                    {
                        var shuffledList = Enumerable.Range(0, n).OrderBy(_ => RandomNumberHelper.GetRandomIntNumber()).ToList();
                        foreach (var idx in shuffledList)
                        {
                            if (finalFxValuesArray[idx] < fxValuesArray[eliteIndex])
                            {
                                finalXRealArray[idx] = xrealArray[eliteIndex];
                                finalFxValuesArray[idx] = fxValuesArray[eliteIndex];
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
}
